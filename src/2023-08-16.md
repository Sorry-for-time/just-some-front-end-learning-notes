---
highlight: atom-one-dark
theme: github
---

# NOTE:

- ä¿®æ­£ä¸€äº›é”™è¯¯æ‹¼å†™(2023-08-16 23:17)...
- æ·»åŠ é™æ€æ–¹æ³• `ToyPromise.resolve(aPromise)` è¿”å›å¹‚ç­‰æ€§è¯´æ˜, æ›´æ–°æ–‡ç« æ ‡æ³¨(2023-08-28 02:44)

# å‡ºå‘ç‚¹

- å›´ç»•ç€æ‰‹å†™ Promise è§„èŒƒå®ç°, å¤§å®¶éƒ½å–œæ¬¢ä¸€äººå†™ä¸€ä¸ª, è¶ç€å‡æœŸæ‘¸é±¼æ—¶é—´ä»¥åŠæ°´å‹ç¾¤ä¹Ÿæœ‰æåˆ°, æˆ‘ä¹Ÿå‚è€ƒå¤šä½å¤§ä½¬ä»¬å·²ç»æ€»ç»“è¿‡çš„è‡ªå·±ä¹Ÿæ¨¡ä»¿(~~æŠ„~~) å†™å‡ºä¸€ä¸ª, åœ¨æ­¤æ»¡è¶³è§„èŒƒå®ç°çš„åŸºç¡€ä¸Š, åšä¸€äº›ä¸æ˜¯é‚£ä¹ˆè§„èŒƒä½†å¥½ç©çš„äº‹æƒ…
- æ–‡ç« ä¸ä¼šä»å¤´åˆ°å°¾å†æ€»ç»“ä¸€é, å› ä¸ºæœ‰å¾ˆå¤šäººå·²ç»æ€»ç»“çš„å¾ˆå¥½äº†, æ‰€ä»¥å°½å¯èƒ½çœæµ, è€Œä¸å¤è¯»æœº
- PS: å®é™…ä¸šåŠ¡ä¸­è¿™ä¹ˆæ•´çš„æ„ä¹‰æ˜¯å•¥æˆ‘è¿˜æš‚æ—¶ä¸æ¸…æ¥š(~~æœ¨æœ‰å·¥ä½œ ğŸ¥²~~ ...)
- ğŸ“Œ ä¼šæåˆ°ä¸€äº›å¯èƒ½æ²¡æ€ä¹ˆè¢«æ³¨æ„åˆ°çš„ `.all, .race. allSettled` è¿™äº›æ–¹æ³•çš„ä¸€äº›è¡Œä¸º(å¦‚ä¸€ä¸ªä»£ç†æ•°ç»„)
- ä¸å°‘ ts æˆ‘ç›´æ¥ copy çš„ ts æ ‡å‡†å†…ç½®å£°æ˜(~~æ²¡æ¯›ç—…~~)
- ä»¥æ­¤å±‘æ–‡æŠ›ç –å¼•ç‰, å¦‚æœ‰é”™è¯¯, è¿˜è¯·æŒ‡å‡º(è½»å–· ğŸ˜¶â€ğŸŒ«ï¸)

# ç½®é¡¶çš„å‚è€ƒé“¾æ¥

- [9k å­— | Promise/async/Generator å®ç°åŸç†è§£æ](https://juejin.cn/post/6844904096525189128)
- [é¢è¯•å®˜ï¼šâ€œä½ èƒ½æ‰‹å†™ä¸€ä¸ª Promise å—â€](https://juejin.cn/post/6850037281206566919?searchId=20230816114352355F513C3C0F32380346)
- [Promises/A+ ç”Ÿè‚‰è§„èŒƒ](https://promisesaplus.com/)
- [Promise/A+ ç†Ÿè‚‰å‚è€ƒ](https://tsejx.github.io/javascript-guidebook/standard-built-in-objects/control-abstraction-objects/promise-standard/)

# çœæµè¯´æ˜

- å»ºè®®ç›´æ¥æ‹‰åˆ°åé¢çœ‹å®ç°ä»£ç (èƒœè¿‡æˆ‘è¿™é‡Œå†™çš„ä¸å’‹çš„æ–‡ç¬”)
- è¯¦ç»†çš„åˆ†æè¿™é‡Œä¸ä¼šå†å†™ä¸€é, å¯ä»¥å‚è€ƒæˆ‘å‚è€ƒçš„é“¾æ¥ $\to$ å¤§ä½¬ä»¬å†™çš„å·²ç»éå¸¸è¯¦ç»†
- Promise çš„å†…éƒ¨çŠ¶æ€å¯ä»¥ç®€çº¦æ¦‚æ‹¬ä¸ºä¸€ä¸ªç®€å•æœ‰é™çŠ¶æ€æœº(`FSM`): å¯ä»¥ä»`pending` åˆ°å…¶å®ƒä¸¤ä¸ªçŠ¶æ€, ä¸”ä¸€çŠ¶æ€è½åœ°(`fulfilled,  rejected`), å°±ä¸èƒ½æ›´æ”¹, è§„èŒƒå®šä¹‰äº†ä¸‰ç§ç±»å‹, ä½†è¿™é‡Œä¸ºäº†å¥½ç©äº›, æ‰€ä»¥ä¸å¦¨åŠ ä¸ª `aborted`, å¯ä»¥å¾—åˆ°å¦‚ä¸‹ä¸€ä¸ªç®€å•çš„æšä¸¾å®šä¹‰(aborted æœ«å°¾ä½¿ç”¨)
  ```typescript
  enum ToyPromiseStatus {
    PENDING = "pending",
    FULFILLED = "fulfilled",
    REJECTED = "rejected",
    ABORTED = "aborted",
  }
  ```
- Promise çš„æ„é€ å™¨æ˜¯ä¸€ä¸ªå‡½æ•°, å†…éƒ¨çš„ä¸¤ä¸ª `functor` (å³ resolve, reject) ç”± Promise å†…éƒ¨æä¾›ä¸ª executor ä½¿ç”¨(æè¿°ä¸ä½³, å»ºè®®ç›´æ¥çœ‹ä»£ç ), å¦‚åç§°ä¸€èˆ¬, å¯ä»¥è®¾ç½® promise çš„çŠ¶æ€å’Œå†…éƒ¨å€¼(`value/reason`)
- `then` çš„è°ƒç”¨ç›¸å½“äºè¿”å›ä¸€ä¸ªæ–°çš„ `Promise` å®ä¾‹ $\to$ `return new ToyPromise(...)`, å¹¶æ ¹æ® `è½åœ°/å¾…å®š` çš„çŠ¶å†µæ¥å†³å®šå¤„ç†æ–¹å¼, å¦‚æœå·²ç»è½åœ°, ç›´æ¥è§£å†³ **(å³å¦‚æœ executor é‡Œçš„ è½åœ°æ–¹æ³•æ²¡æ”¾åœ¨ setTimeout ç­‰çš„è¯, é‚£ä¹ˆçŠ¶æ€å·²ç»è¢«æ”¹å˜, åœ¨ then é‡Œå–å¾—æ—¶å·²ç»æ˜¯è½åœ°çŠ¶æ€)**, å¦‚æœæ˜¯ pending, é‚£ä¹ˆè¡¨æ˜ executor é‡Œæ‰§è¡Œ resolve/reject å¯èƒ½æ”¾åœ¨ç±»ä¼¼ setTimeout çš„å¼‚æ­¥åŒ…è£…é‡Œ, æ­¤æ—¶å¯åœ¨å†…éƒ¨è®¾ç½®ä¸¤ä¸ªé˜Ÿåˆ—åˆ†åˆ«ä¿å­˜ä¸¤ç§å¯èƒ½è§¦å‘çš„äº‹ä»¶, ç­‰ executor é‡Œå¼‚æ­¥åŒ…è£…çš„ resolve/reject æ‰§è¡Œæ—¶æœºåˆ°æ¥å, å„è‡ªä»é˜Ÿåˆ—é‡Œå–å‡ºæ‰§è¡Œ(å½“ç„¶, è°å…ˆæ‰§è¡Œ, å°±ä»£è¡¨çŠ¶æ€è½åœ°), ä¸” then çš„ `onFulfilled` é‡Œè¿”å›çš„å€¼å¯ä»¥åœ¨ä¸‹ä¸€ä¸ª then é‡Œè·å–, ä¸”å¦‚æœæ˜¯ Thenable, é‚£ä¹ˆéœ€è¦é€’å½’å¤„ç†, ç­‰å¾…å®Œæˆè·å–
- å…·ä½“çš„å¾®ä»»åŠ¡å®ç°æ–¹å¼ä½¿ç”¨: `queueMicrotask(VoidFunction)` æ¨¡æ‹Ÿ
- catch, finally å®é™…ä¸Šæ˜¯é¢„å…ˆç­¾åç‰ˆæœ¬(æå‰è®¾ç½® then çš„å‚æ•°)
- ...

# ä»£ç 

## ä¸€ä¸ªåŸºç¡€å®ç°çš„è‡ªå®šä¹‰ Promise

- æè¿°è¿‡äºæ¯ç‡¥, å…ˆçœ‹ä¸€ä¸ªåŸºç¡€å®ç°ç‰ˆ(PS: å€Ÿé‰´äº†å‚è€ƒæ–‡ç« é‡Œçš„ä»£ç å®ç°å’Œ ts å†…ç½®æ ‡å‡†ç±»å£°æ˜)

  ```typescript
  enum ToyPromiseStatus {
    PENDING = "pending",
    FULFILLED = "fulfilled",
    REJECTED = "rejected",
  }

  type ToyPromiseAwaited<T> = T extends null | undefined
    ? T
    : T extends object & { then(onfulfilled: infer F, ...args: infer _): any }
    ? F extends (value: infer V, ...args: infer _) => any
      ? ToyPromiseAwaited<V>
      : never
    : T;

  interface Thenable<T> {
    then<TResult1 = T, TResult2 = never>(
      onFulfilled?:
        | ((value: T) => TResult1 | Thenable<TResult1>)
        | undefined
        | null,
      onRejected?:
        | ((reason: any) => TResult2 | Thenable<TResult2>)
        | undefined
        | null
    ): Thenable<TResult1 | TResult2>;
  }

  type ExecutorType<T> = (
    resolve: (value: T) => void,
    reject: (reason: any) => void
  ) => void;

  type ToyPromiseAllSettledResult<T> =
    | { status: "fulfilled"; value: T }
    | {
        status: "rejected";
        reason: any;
      };

  class ToyPromise<T> implements Thenable<T> {
    #state: ToyPromiseStatus;

    #value!: T;

    #reason: any;

    readonly #resolvedCallbacks: Array<(value: T) => void>;

    readonly #rejectedCallbacks: Array<(reason: any) => void>;

    public constructor(executor: ExecutorType<T>) {
      if (typeof executor !== "function") {
        throw new TypeError(
          `ToyPromise resolver #<${typeof executor}> is not a function`
        );
      }

      this.#state = ToyPromiseStatus.PENDING;
      this.#resolvedCallbacks = [];
      this.#rejectedCallbacks = [];

      try {
        executor(this.#resolve.bind(this), this.#reject.bind(this));
      } catch (reason: any) {
        this.#reject(reason);
      }
    }

    #resolve(value: T): void {
      // å¤„ç†å¾ªç¯å¼•ç”¨
      if (<ToyPromise<T>>value === this) {
        this.#reject(
          new TypeError(
            "Chaining cycle detected for promise #<OptionalPromise>"
          )
        );
        return;
      }
      if (value instanceof Promise || value instanceof ToyPromise) {
        (<Thenable<T>>value).then(
          this.#resolve.bind(this),
          this.#reject.bind(this)
        );
        return;
      }
      if (this.#state === ToyPromiseStatus.PENDING) {
        this.#value = value;
        this.#state = ToyPromiseStatus.FULFILLED;
        for (const cb of this.#resolvedCallbacks) {
          cb(this.#value);
        }
      }
    }

    #reject(reason: any): void {
      if (this.#state === ToyPromiseStatus.PENDING) {
        this.#reason = reason;
        this.#state = ToyPromiseStatus.REJECTED;
        for (const cb of this.#rejectedCallbacks) {
          cb(this.#reason);
        }
      }
    }

    static #processThenableOrNor<T>(
      promise: ToyPromise<T>,
      value: any,
      resolve: (value: T) => void,
      reject: (reason: any) => void
    ) {
      if (promise === value) {
        return reject(
          new TypeError(
            `Chaining cycle detected for promise #<OptionalPromise>`
          )
        );
      }
      let isCall: boolean = false;
      if ((value && typeof value === "object") || typeof value === "function") {
        /*
          ä½¿ç”¨ try-catch é¿å…å¦‚ä¸‹æƒ…å†µ
          Object.defineProperty(obj, "then", {
            get() {
              throw new Error("msg xxx")
            }
          })
        */
        try {
          const thenFunctor:
            | ((
                resolve: (value: T) => void,
                reject: (reason: any) => void
              ) => any)
            | undefined
            | null = value["then"];

          if (typeof thenFunctor === "function") {
            thenFunctor.call(
              value,
              (y) => {
                if (!isCall) {
                  isCall = true;
                  this.#processThenableOrNor(value, y, resolve, reject);
                }
              },
              (r) => {
                if (!isCall) {
                  isCall = true;
                  reject(r);
                }
              }
            );
          } else {
            resolve!(value);
          }
        } catch (reason) {
          if (!isCall) {
            isCall = true;
            reject(reason);
          }
        }
      } else {
        resolve!(value);
      }
    }

    public then<E = T, R = never>(
      onFulfilled?: ((value: T) => E | Thenable<E>) | undefined | null,
      onRejected?: ((reason: any) => R | Thenable<R>) | undefined | null
    ): ToyPromise<E | R> {
      onFulfilled =
        typeof onFulfilled === "function"
          ? onFulfilled
          : (val) => val as Thenable<E>;
      onRejected =
        typeof onRejected === "function"
          ? onRejected
          : (reason) => {
              throw reason;
            };
      const retPromise = new ToyPromise<E | R>((resolve, reject) => {
        switch (this.#state) {
          case ToyPromiseStatus.FULFILLED:
            queueMicrotask(() => {
              try {
                ToyPromise.#processThenableOrNor(
                  retPromise,
                  onFulfilled!(this.#value),
                  resolve,
                  reject
                );
              } catch (reason) {
                reject(reason);
              }
            });
            break;
          case ToyPromiseStatus.REJECTED:
            queueMicrotask((): void => {
              try {
                ToyPromise.#processThenableOrNor(
                  retPromise,
                  onRejected!(this.#reason),
                  resolve,
                  reject
                );
              } catch (reason) {
                reject(reason);
              }
            });
            break;
          case ToyPromiseStatus.PENDING:
            this.#resolvedCallbacks.push((value: T): void =>
              queueMicrotask((): void => {
                try {
                  ToyPromise.#processThenableOrNor(
                    retPromise,
                    onFulfilled!(value),
                    resolve,
                    reject
                  );
                } catch (reason) {
                  reject(reason);
                }
              })
            );
            this.#rejectedCallbacks.push((reason: any): void =>
              queueMicrotask((): void => {
                try {
                  ToyPromise.#processThenableOrNor(
                    retPromise,
                    onRejected!(reason),
                    resolve,
                    reject
                  );
                } catch (reason) {
                  reject(reason);
                }
              })
            );
            break;
          default:
            break;
        }
      });

      return retPromise;
    }
  }
  ```

- å†™çš„é›¶é›¶æ•£æ•£, å…ˆç®€å•æµ‹è¯•ä¸€ä¸‹(ç»“æœè¿˜ç®— OK)

  ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a15471852134353aaaa0edef663463a~tplv-k3u1fbpfcp-watermark.image?)

## å®ç° catch, finally ä»¥åŠé™æ€æ–¹æ³•

- è¿™é‡Œçœç•¥å‰é¢å·²æœ‰ä»£ç ...

  ```typescript
  class ToyPromise<T> implements Thenable<T> {
    // å‰é¢é‚£äº›ä»£ç ....

    public catch<TResult = never>(
      onRejected?:
        | ((reason: any) => TResult | Thenable<TResult>)
        | undefined
        | null
    ): ToyPromise<T | TResult> {
      return this.then(null, onRejected) as any;
    }

    public finally(onFinally?: (() => void) | undefined | null): ToyPromise<T> {
      onFinally = typeof onFinally === "function" ? onFinally : () => {};
      return this.then(
        (value) => ToyPromise.resolve(onFinally!()).then(() => value),
        (reason) =>
          ToyPromise.resolve(onFinally!()).then(() => {
            throw reason;
          })
      );
    }

    static #isThenable(obj: any): boolean {
      if ((obj && typeof obj === "object") || typeof obj === "function") {
        return typeof obj["then"] === "function";
      }
      return false;
    }

    static #isIterable(obj: any): boolean {
      // é¿å… "" ç©ºå­—ç¬¦(é‚£ä¹ˆæ˜¯ iterable) è¢«åˆ¤æ–­ä¸º false æ¡ä»¶
      if (typeof obj === "string") {
        return true;
      }
      // å¦‚æœæ˜¯ null ç›´æ¥è¿”å› false
      if (typeof obj === "object" && !obj) {
        return false;
      }
      // åˆ¤æ–­æ˜¯å¦ä¸ºå¯è¿­ä»£å¯¹è±¡
      if (typeof obj === "function" || typeof obj === "object") {
        /*
            å…¼å®¹å¦‚ä¸‹è¿™ç§ç¤ºä¾‹æƒ…å†µ
            function foo() {}
            foo[Symbol.iterator] = () => { yield 233 }
          */
        return typeof obj[Symbol.iterator] === "function";
      } else {
        return false;
      }
    }

    public static all<T>(
      values: Iterable<T | PromiseLike<T>>
    ): ToyPromise<ToyPromiseAwaited<T>[]>;
    public static all<T extends readonly unknown[] | []>(
      values: T
    ): ToyPromise<{ -readonly [P in keyof T]: ToyPromiseAwaited<T[P]> }>;
    public static all<T>(values: any) {
      return new ToyPromise<any>((resolve, reject) => {
        // å¦‚æœæ¥æ”¶å€¼ä¸å¯è¿­ä»£, ç›´æ¥è¿”å›ä¸€ä¸ªåŒ…å«é”™è¯¯æç¤ºçš„ ToyPromise
        if (!this.#isIterable(values)) {
          throw new TypeError(
            `${typeof values} ${values} is not iterable (cannot read property Symbol(Symbol.iterator))`
          );
        } else {
          // å·²è§£å†³ç»Ÿè®¡
          let resolvedCount: number = 0;
          // å­˜æ”¾å·²è§£å†³å€¼çš„æ•°ç»„
          const resolvedList: Array<any> = [];
          const processStatus = (idx: number, data: any, countLen: number) => {
            resolvedList[idx] = data;
            if (++resolvedCount === countLen) {
              resolve(resolvedList as any);
            }
          };
          // å¦‚æœæ˜¯æ­£å¸¸ Array, ç›´æ¥éå†
          if (Array.isArray(values)) {
            const len0: number = values.length;
            loop: for (let i: number = 0; i < len0; ++i) {
              const current: any = values[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then((value) => {
                  processStatus(i, value, len0);
                }, reject);
              } else {
                processStatus(i, current, len0);
              }
            }
          } else {
            const tmpList: Array<any> = [];
            for (const val of values) {
              tmpList.push(val);
            }
            const len1: number = tmpList.length;
            for (let i: number = 0; i < len1; ++i) {
              const current = tmpList[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then((value) => {
                  processStatus(i, value, len1);
                }, reject);
              } else {
                processStatus(i, current, len1);
              }
            }
          }
        }
      });
    }

    public static allSettled<T>(
      values: Iterable<T | Thenable<T>>
    ): ToyPromise<ToyPromiseAllSettledResult<ToyPromiseAwaited<T>>[]>;
    public static allSettled<T extends readonly unknown[] | []>(
      values: T
    ): ToyPromise<{
      -readonly [P in keyof T]: ToyPromiseAllSettledResult<
        ToyPromiseAwaited<T[P]>
      >;
    }>;
    public static allSettled<T>(values: any) {
      return new ToyPromise<any>((resolve) => {
        if (!this.#isIterable(values)) {
          if (!this.#isIterable(values)) {
            throw new TypeError(
              `${typeof values} ${values} is not iterable (cannot read property Symbol(Symbol.iterator))`
            );
          }
        } else {
          let doneCount: number = 0;
          const doneList: Array<any> = [];
          const processStatus = (
            idx: number,
            data: any,
            tType:
              | ToyPromiseStatus.FULFILLED
              | ToyPromiseStatus.REJECTED = ToyPromiseStatus.FULFILLED,
            length: number
          ): void => {
            doneList[idx] = {
              status:
                tType === ToyPromiseStatus.FULFILLED
                  ? tType
                  : ToyPromiseStatus.REJECTED,
              [tType === ToyPromiseStatus.FULFILLED ? "value" : "reason"]: data,
            };
            if (++doneCount === length) {
              resolve(doneList as any);
            }
          };

          if (Array.isArray(values)) {
            const arrLen0: number = values.length;
            for (let i: number = 0; i < arrLen0; ++i) {
              const current: any = values[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then(
                  (value) => {
                    processStatus(
                      i,
                      value,
                      ToyPromiseStatus.FULFILLED,
                      arrLen0
                    );
                  },
                  (reason) => {
                    processStatus(
                      i,
                      reason,
                      ToyPromiseStatus.REJECTED,
                      arrLen0
                    );
                  }
                );
              } else {
                processStatus(i, current, ToyPromiseStatus.FULFILLED, arrLen0);
              }
            }
          } else {
            const tmpList: Array<any> = [];
            for (const val of values) {
              tmpList.push(val);
            }
            const arrLen1: number = tmpList.length;
            for (let i: number = 0; i < arrLen1; ++i) {
              const current = tmpList[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then(
                  (value) => {
                    processStatus(
                      i,
                      value,
                      ToyPromiseStatus.FULFILLED,
                      arrLen1
                    );
                  },
                  (reason) => {
                    processStatus(
                      i,
                      reason,
                      ToyPromiseStatus.REJECTED,
                      arrLen1
                    );
                  }
                );
              } else {
                processStatus(i, current, ToyPromiseStatus.FULFILLED, arrLen1);
              }
            }
          }
        }
      });
    }

    public static any<T>(
      values: Iterable<T | PromiseLike<T>>
    ): ToyPromise<ToyPromiseAwaited<T>>;
    public static any<T extends readonly unknown[] | []>(
      values: T
    ): ToyPromise<ToyPromiseAwaited<T[number]>>;
    public static any<T>(values: any) {
      return new ToyPromise((resolve, reject) => {
        if (!this.#isIterable(values)) {
          throw new TypeError(
            `${typeof values} ${values} is not iterable (cannot read property Symbol(Symbol.iterator))`
          );
        } else {
          let rejectedCount: number = 0;
          if (Array.isArray(values)) {
            const len0: number = values.length;
            for (let i: number = 0; i < len0; ++i) {
              const current: any = values[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then(resolve as any, () => {
                  if (++rejectedCount === len0) {
                    reject(new AggregateError("All promises were rejected"));
                  }
                });
              } else {
                resolve(current as any);
              }
            }
          } else {
            const tmpList: Array<any> = [];
            for (const val of values) {
              tmpList.push(val);
            }
            const len1: number = tmpList.length;
            for (let i: number = 0; i < len1; ++i) {
              const current: any = tmpList[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then(resolve as any, () => {
                  if (++rejectedCount === len1) {
                    reject(new AggregateError("All promises were rejected"));
                  }
                });
              } else {
                resolve(current as any);
              }
            }
          }
        }
      });
    }

    public static race<T>(
      values: Iterable<T | Thenable<T>>
    ): ToyPromise<ToyPromiseAwaited<T>>;
    public static race<T extends readonly unknown[] | []>(
      values: T
    ): ToyPromise<ToyPromiseAwaited<T[number]>>;
    public static race<T>(values: any) {
      return new ToyPromise((resolve, reject) => {
        for (const val of values) {
          if (this.#isThenable(val)) {
            (<Thenable<T>>val).then(resolve as any, reject);
          } else {
            resolve(val as any);
          }
        }
      });
    }

    public static resolve(): ToyPromise<void>;
    public static resolve<T>(value: T): ToyPromise<ToyPromiseAwaited<T>>;
    public static resolve<T>(
      value: T | Thenable<T>
    ): ToyPromise<ToyPromiseAwaited<T>>;
    public static resolve(value?: any) {
      // è¿”å›å¹‚ç­‰, å…¼å®¹åŸç”Ÿ Promise å’Œè‡ªå®šä¹‰ Promise
      /*
        const p1 = new ToyPromise(()=> {});
        const p2 = ToyPromise.resolve(p1);
        console.log(p1 === p2); // true
      */

      /*
       const p1 = new ToyPromise((_ignored, reject) => {
        reject(111);
      });
        const p2 = ToyPromise.resolve(p1);
        console.log(p1 === p2); // true
      */
      if (value instanceof ToyPromise || value instanceof Promise) {
        return value;
      }
      return new ToyPromise((resolve) => {
        resolve(value);
      });
    }

    public static reject<T = never>(reason?: any): ToyPromise<T> {
      return new ToyPromise<T>((_ignore, reject) => {
        reject(reason);
      });
    }

    public get [Symbol.toStringTag](): string {
      return "ToyPromise";
    }
  }
  ```

  æ˜¯æ—¶å€™å†™ä¸ªç®€å• demo äº†

  ```typescript
  ToyPromise.all([
    1,
    2,
    new Promise<number>((resolve) => setTimeout(resolve, 1000, 3)),
    new ToyPromise<number>((resolve) => setTimeout(resolve, 600, 4)),
    ToyPromise.resolve(5),
  ])
    .then((values: Array<number>) => {
      console.log(values);
      return ToyPromise.reject("why");
    })
    .then()
    .catch()
    .catch((reason) => {
      console.warn(reason);
    })
    .then()
    .finally(() => {
      console.log("done1");
    })
    .then()
    .finally(() => {
      console.log("done2");
    });
  ```

  æµè§ˆå™¨è¾“å‡º
  ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3572bb98e0a4475f93545ddb8de6ec3c~tplv-k3u1fbpfcp-watermark.image?)

## æ·»åŠ æœªæ•è·é”™è¯¯æ§åˆ¶å°è¾“å‡ºæé†’

- ç›®å‰ä¸ºæ­¢çœ‹ä¸Šå»å¥½åƒè¿˜å¯ä»¥, ä½†æœ‰æ—¶æˆ‘ä»¬ä¼šæ³¨æ„åˆ°åŸç”Ÿå®ç°åœ¨æ‹’ç»åå¦‚æœæ²¡æœ‰é”™è¯¯æ•è·, å¤„ç†, æµè§ˆå™¨ä¼šç»™ä¸€ä¸ªæ§åˆ¶å°çª—å£ error æç¤º(æç¤ºä¸€æ¬¡), å¦‚è¿™æ ·
  ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2062a9dadf6d41c2a36f8d0788326da7~tplv-k3u1fbpfcp-watermark.image?)
- æˆ‘ä»¬è¿™é‡Œä½œä¸€äº›ç®€å•å¤„ç†, ä»¥æ­¤è¾¾åˆ°ç±»ä¼¼æ•ˆæœ, æˆ‘ä»¬éœ€è¦ä¸€ä¸ªè®°å½•ä¿å­˜æ˜¯å¦æœ‰æœªæ•è·çš„æ‹’ç»å¤„ç†, ä¸”ç¡®ä¿åªè¾“å‡ºä¸€æ¬¡, é‚£ä¹ˆå¯ä»¥è¿™ä¹ˆä¿®æ”¹(å¦‚å›¾ $\to$ èŠ‚çœç¯‡å¹…, è¿™é‡Œåªæˆªå– code æˆªå±)
  ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abb1d6fd6534709873f74e0bb9e2db2~tplv-k3u1fbpfcp-watermark.image?)
  ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7074858713f421bbcb37120636866d8~tplv-k3u1fbpfcp-watermark.image?)
  ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4f983c3637b4b50a656cde0e174f5d4~tplv-k3u1fbpfcp-watermark.image?)
  ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcc55feeac344dab9e0b94b9b5f59f7f~tplv-k3u1fbpfcp-watermark.image?)
  ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c767b7346b78495884209e1769f63718~tplv-k3u1fbpfcp-watermark.image?)

  ```typescript
  Promise.reject("why")
    .then(() => {
      throw new Error("1");
    })
    .catch(() => {
      throw new Error("2");
    })
    .finally()
    .then(() => {
      return new Promise((_, reject) => {
        reject("3");
      });
    })
    .catch();

  ToyPromise.reject("why")
    .then(() => {
      throw new Error("1");
    })
    .catch(() => {
      throw new Error("2");
    })
    .finally()
    .then(() => {
      return new Promise((_, reject) => {
        reject("3");
      });
    })
    .catch();

  Promise.reject("nothing").finally().catch(console.warn);
  ToyPromise.reject("nothing").finally().catch(console.warn);
  ```

  ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecd5e7a24bf24fe08ba1ef59861876ef~tplv-k3u1fbpfcp-watermark.image?)

# ğŸ“Œ åŸç”Ÿé™æ€æ–¹æ³• `Promise.all(values), Promise.any(values)` ... å¯èƒ½çš„ä¸€äº›é¢„æœŸå¤–è¡Œä¸º,

- PS: æµ‹è¯•æµè§ˆå™¨ä¸º Chrome(116.0.5845.111), å¦‚æœç¯å¢ƒä¸åŒ, æˆ–è€…ç‰ˆæœ¬ä¸åŒ, ä½ å¯èƒ½å¾—åˆ°çš„æµ‹è¯•ç»“æœä¸æˆ‘è¿™é‡Œä¸ä¸€å®šä¸€è‡´
- è¿™ä¸ªé—®é¢˜æ˜¯æˆ‘åœ¨å®ç° `.all, .any...` è¿™äº›é™æ€æ–¹æ³•æ—¶æƒ³åˆ°çš„, å¦‚æœä¼ å…¥çš„ values æ˜¯ä¸€ä¸ªæ•°ç»„çš„ä»£ç†å¯¹è±¡, ä¸”å¦‚æœæ°å¥½ get é‡Œæœ‰äº›é¢å¤–è¡Œä¸º, ä¼šå¦‚ä½•? ç›´æ¥å†™ä¸€ä¸ªç®€å•ç¤ºä¾‹(ç›¸ä¿¡å¾ˆç›´è§‚)

  ```typescript
  const baseArr: Array<number> = [1, 2, 3];
  const proxyArr = new Proxy(baseArr, {
    get(target, p, receiver) {
      console.log("tricker --1");
      return Reflect.get(target, p, receiver);
    },
  });

  function* gen() {
    for (let i: number = 1; i <= 3; ++i) {
      console.log("tricker --2");

      yield i;
    }
  }
  // å¯èƒ½å‡ºç°ä¸€äº›éé¢„æœŸå†…çš„è¡Œä¸º, ä½†è¿™é‡Œä¸ä½œä¸ºæ¢è®¨
  Promise.all(proxyArr);
  Promise.all(gen());
  ```

  ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09aff9b2ed8b44038f9ce19fe3b834ea~tplv-k3u1fbpfcp-watermark.image?)
  ä¸å¦¨ç®€å•ç²—æš´çŒœæµ‹ä¸‹~~(è¿‡äºç›´çƒ)~~å¯¹äºæ•°ç»„å¤„ç†å†…éƒ¨ç›´æ¥éå†äº† 12 æ¬¡ + 2 æ¬¡è¯»å–æ•°ç»„é•¿åº¦`(PS: z è¿™é‡Œå­˜ç²¹çš„ä¸»è§‚çŒœæµ‹, é”™äº†è½»å–· ğŸ¤£), è€Œå¯¹äºéæ•°ç»„çš„å¯è¿­ä»£å¯¹è±¡, åˆ™å¯èƒ½é‡‡ç”¨æ”¶é›†åˆ°å¦å¤–ä¸€ä¸ªå®¹å™¨çš„å½¢å¼å†æ¬¡è¯»å–åˆ¤æ–­çš„æ–¹å¼(æˆ‘è‡ªå·±å†™çš„å®ç°å®é™…ä¸Šä¹Ÿæ˜¯è¿™ä¹ˆåš) ğŸ˜¶â€ğŸŒ«ï¸

# å®Œæ•´çš„ä»£ç å®ç°(åˆè‡­åˆé•¿)

- è®°å¾—å¼€å¤´æšä¸¾å®šä¹‰çš„ `ABORTED` å—, è¿™é‡Œæ·»åŠ ä¸€ä¸ª `abort(): boolean` ç”¨äºå–æ¶ˆä¸€ä¸ªçŠ¶æ€ä¸º pending çš„è‡ªå®šä¹‰ Promise å®ä¾‹(åŒæ ·ä¸å¯é€†), ä¸”è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ç”¨æ¥åˆ¤æ–­æ˜¯å¦å”‰çŠ¶æ€è½åœ°å‰å–æ¶ˆäº†ä»»åŠ¡

  ```typescript
  /**
   * è‡ªå®šä¹‰ ToyPromise çŠ¶æ€
   */
  enum ToyPromiseStatus {
    PENDING = "pending",
    FULFILLED = "fulfilled",
    REJECTED = "rejected",
    ABORTED = "aborted",
  }

  type ToyPromiseAwaited<T> = T extends null | undefined
    ? T
    : T extends object & { then(onfulfilled: infer F, ...args: infer _): any }
    ? F extends (value: infer V, ...args: infer _) => any
      ? ToyPromiseAwaited<V>
      : never
    : T;

  /**
   * PromiseLike å®šä¹‰(æ‘˜è‡ª ts é»˜è®¤å†…ç½®å®šä¹‰)
   */
  interface Thenable<T> {
    then<TResult1 = T, TResult2 = never>(
      onFulfilled?:
        | ((value: T) => TResult1 | Thenable<TResult1>)
        | undefined
        | null,
      onRejected?:
        | ((reason: any) => TResult2 | Thenable<TResult2>)
        | undefined
        | null
    ): Thenable<TResult1 | TResult2>;
  }

  /**
   * æ‰§è¡Œå™¨å‡½æ•°ç±»å‹
   */
  type ExecutorType<T> = (
    resolve: (value: T) => void,
    reject: (reason: any) => void
  ) => void;

  /**
   * æ‰€æœ‰è‡ªå®šä¹‰ Promise çŠ¶æ€ç¡®å®šæ‰€è¿”å›çš„å€¼
   */
  type ToyPromiseAllSettledResult<T> =
    | { status: "fulfilled"; value: T }
    | {
        status: "rejected";
        reason: any;
      };

  /**
   * è‡ªå®šä¹‰ Promise A+ è§„èŒƒç®€å•å®ç°
   *
   * @implements Thenable<T> å®ç°äº† Thenable æ¥å£å¹¶ä¸”ç»§æ‰¿å…¶ç±»å‹
   * @template T æ•°æ®ç±»å‹
   * @author Shalling
   * @version 0.01
   */
  class ToyPromise<T> implements Thenable<T> {
    /**
     * è‡ªå®šä¹‰ Promise çš„çŠ¶æ€
     */
    #state: ToyPromiseStatus;

    /**
     * è‡ªå®šä¹‰ Promise å·²è§£å†³æ—¶æ‰€åŒ…å«çš„å€¼
     */
    #value!: T;

    /**
     * è‡ªå®šä¹‰ Promise å¤„äºæ‹’ç»æ—¶åŒ…å«çš„å€¼
     */
    #reason: any;

    /**
     * å·²è§£å†³å›è°ƒå‡½æ•°é˜Ÿåˆ—
     */
    readonly #resolvedCallbacks: Array<(value: T) => void>;

    /**
     * å·²æ‹’ç»å›è°ƒå‡½æ•°é˜Ÿåˆ—
     */
    readonly #rejectedCallbacks: Array<(reason: any) => void>;

    /**
     * è®°å½•å¤„äºå·²æ‹’ç»çŠ¶æ€æ—¶, æ˜¯å¦æä¾›äº†å¼‚å¸¸å¤„ç†å‡½æ•°
     */
    #hasRejectedHandler: boolean;

    /**
     * å®ä¾‹åˆå§‹åŒ–æ„é€ å™¨
     *
     * @param executor çŠ¶æ€ç¡®å®šæ‰§è¡Œå™¨å‡½æ•°
     */
    public constructor(executor: ExecutorType<T>) {
      if (typeof executor !== "function") {
        throw new TypeError(
          `ToyPromise resolver #<${typeof executor}> is not a function`
        );
      }

      this.#hasRejectedHandler = false;
      this.#state = ToyPromiseStatus.PENDING;
      this.#resolvedCallbacks = [];
      this.#rejectedCallbacks = [];

      try {
        executor(this.#resolve.bind(this), this.#reject.bind(this));
      } catch (reason: any) {
        this.#reject(reason);
      }
    }

    /**
     * æä¾›ç»™çŠ¶æ€æ‰§è¡Œå™¨å‡½æ•°çš„ `å·²è§£å†³` å‡½æ•°
     *
     * @param value `å·²è§£å†³` å€¼
     * @template T é»˜è®¤æ•°æ®ç±»å‹
     */
    #resolve(value: T): void {
      if (<ToyPromise<T>>value === this) {
        this.#reject(
          new TypeError(
            "Chaining cycle detected for promise #<OptionalPromise>"
          )
        );
        return;
      }
      if (value instanceof Promise || value instanceof ToyPromise) {
        (<Thenable<T>>value).then(
          this.#resolve.bind(this),
          this.#reject.bind(this)
        );
        return;
      }
      // TODO: WAIT RESOLVE
      // if (ToyPromise.#isThenable(value)) {
      //   ToyPromise.#processThenableOrNor(this, value, this.#resolve.bind(this), this.#reject.bind(this));
      //   return;
      // }
      if (this.#state === ToyPromiseStatus.PENDING) {
        this.#value = value;
        this.#state = ToyPromiseStatus.FULFILLED;
        for (const cb of this.#resolvedCallbacks) {
          cb(this.#value);
        }
      }
    }

    /**
     * æä¾›ç»™çŠ¶æ€æ‰§è¡Œå™¨å‡½æ•°çš„ `å·²æ‹’ç»` å‡½æ•°
     *
     * @param reason `å·²æ‹’ç»` åŸå› 
     * @private
     */
    #reject(reason: any): void {
      if (this.#state === ToyPromiseStatus.PENDING) {
        this.#reason = reason;
        this.#state = ToyPromiseStatus.REJECTED;
        for (const cb of this.#rejectedCallbacks) {
          cb(this.#reason);
        }
        queueMicrotask(() => {
          if (!this.#hasRejectedHandler) {
            console.error(`Uncaught (in toy-promise)ğŸ“Œ`, reason);
          }
        });
      }
    }

    /**
     * é€šè¿‡é€’å½’æ–¹å¼å¤„ç†å¯èƒ½ä¸º `Thenable` ç»“æ„çš„å¯¹è±¡
     *
     * @param promise è‡ªå®šä¹‰ Promise å®ä¾‹
     * @param value è¿›è¡Œåˆ¤æ–­å¤„ç†çš„å€¼
     * @param resolve å·²è§£å†³å‡½æ•°
     * @param reject å·²æ‹’ç»å‡½æ•°
     * @template T é»˜è®¤æ•°æ®ç±»å‹
     */
    static #processThenableOrNor<T>(
      promise: ToyPromise<T>,
      value: any,
      resolve: (value: T) => void,
      reject: (reason: any) => void
    ) {
      if (promise === value) {
        return reject(
          new TypeError(
            `Chaining cycle detected for promise #<OptionalPromise>`
          )
        );
      }
      let isCall: boolean = false;
      if ((value && typeof value === "object") || typeof value === "function") {
        /*
          ä½¿ç”¨ try-catch é¿å…å¦‚ä¸‹æƒ…å†µ
          Object.defineProperty(obj, "then", {
            get() {
              throw new Error("msg xxx")
            }
          })
        */
        try {
          const thenFunctor:
            | ((
                resolve: (value: T) => void,
                reject: (reason: any) => void
              ) => any)
            | undefined
            | null = value["then"];
          if (typeof thenFunctor === "function") {
            thenFunctor.call(
              value,
              (y) => {
                if (!isCall) {
                  isCall = true;
                  this.#processThenableOrNor(value, y, resolve, reject);
                }
              },
              (r) => {
                if (!isCall) {
                  isCall = true;
                  reject(r);
                }
              }
            );
          } else {
            resolve!(value);
          }
        } catch (reason) {
          if (!isCall) {
            isCall = true;
            reject(reason);
          }
        }
      } else {
        resolve!(value);
      }
    }

    /**
     * è¿”å›é“¾å¼ç”Ÿæˆçš„è‡ªå®šä¹‰ promise å®ä¾‹
     *
     * @param onFulfilled `å·²è§£å†³` çŠ¶æ€æ•è·å‡½æ•°
     * @param onRejected `å·²æ‹’ç»/é”™è¯¯` çŠ¶æ€æ•è·è°ƒå‡½æ•°
     * @template T æ¥æ”¶çš„å·²è§£å†³ç±»å‹
     * @template R æ¥æ”¶çš„ä»¥å†³ç»ç±»å‹
     * @return ToyPromise ä¸€ä¸ªæ–°çš„è‡ªå®šä¹‰ promise å®ä¾‹
     */
    public then<E = T, R = never>(
      onFulfilled?: ((value: T) => E | Thenable<E>) | undefined | null,
      onRejected?: ((reason: any) => R | Thenable<R>) | undefined | null
    ): ToyPromise<E | R> {
      onFulfilled =
        typeof onFulfilled === "function"
          ? onFulfilled
          : (val) => val as Thenable<E>;
      onRejected =
        typeof onRejected === "function"
          ? onRejected
          : (reason) => {
              throw reason;
            };
      const retPromise = new ToyPromise<E | R>((resolve, reject) => {
        switch (this.#state) {
          case ToyPromiseStatus.FULFILLED:
            queueMicrotask(() => {
              try {
                ToyPromise.#processThenableOrNor(
                  retPromise,
                  onFulfilled!(this.#value),
                  resolve,
                  reject
                );
              } catch (reason) {
                reject(reason);
              }
            });
            break;
          case ToyPromiseStatus.REJECTED:
            queueMicrotask((): void => {
              try {
                ToyPromise.#processThenableOrNor(
                  retPromise,
                  onRejected!(this.#reason),
                  resolve,
                  reject
                );
              } catch (reason) {
                reject(reason);
              }
            });
            break;
          /*
            å¦‚æœæ˜¯ pending çŠ¶æ€(å¦‚ executor åœ¨ setTimeout ä¸­æ‰§è¡Œ), åˆ™å°†åŒ…è£…å‡½æ•°æ¨å…¥é˜Ÿåˆ—,
            ç­‰ executor åˆ°è¾¾æ‰§è¡ŒçŠ¶æ€, å†…éƒ¨çš„ #resolve(val), #reject(reason) å„è‡ªéå† `pending` çŠ¶æ€æ—¶æ¨å…¥é˜Ÿåˆ—é‡Œçš„åŒ…è£…å‡½æ•°
          */
          case ToyPromiseStatus.PENDING:
            this.#resolvedCallbacks.push((value: T): void =>
              queueMicrotask((): void => {
                try {
                  ToyPromise.#processThenableOrNor(
                    retPromise,
                    onFulfilled!(value),
                    resolve,
                    reject
                  );
                } catch (reason) {
                  reject(reason);
                }
              })
            );
            this.#rejectedCallbacks.push((reason: any): void =>
              queueMicrotask((): void => {
                try {
                  ToyPromise.#processThenableOrNor(
                    retPromise,
                    onRejected!(reason),
                    resolve,
                    reject
                  );
                } catch (reason) {
                  reject(reason);
                }
              })
            );
            break;
          default:
            break;
        }
      });

      this.#hasRejectedHandler = true;
      return retPromise;
    }

    /**
     * `é”™è¯¯/å·²æ‹’ç»` çŠ¶æ€å¤„ç†æ–¹æ³•
     *
     * @param onRejected `å·²æ‹’ç»/é”™è¯¯` çŠ¶æ€æ•è·è°ƒå‡½æ•°
     * @define è¿™ä¸ªæ–¹æ³•ä¸º `then` æ–¹æ³•çš„ç­¾å
     * @return ToyPromise ä¸€ä¸ªæ–°çš„è‡ªå®šä¹‰ promise å®ä¾‹
     */
    public catch<TResult = never>(
      onRejected?:
        | ((reason: any) => TResult | Thenable<TResult>)
        | undefined
        | null
    ): ToyPromise<T | TResult> {
      return this.then(null, onRejected) as any;
    }

    /**
     * æœ€ç»ˆæ‰§è¡Œå‡½æ•°(è¿™ä¸ªæ–¹ä¸º `then` æ–¹æ³•çš„ç­¾åç‰ˆæœ¬)
     *
     * @param onFinally å›è°ƒæ‰§è¡Œå‡½æ•°
     * @return ä¸€ä¸ªæ–°çš„è‡ªå®šä¹‰ promise å®ä¾‹(ä¼šä¿æŒä¹‹å‰çš„ `å·²è§£å†³/å·²æ‹’ç»` çŠ¶æ€
     */
    public finally(onFinally?: (() => void) | undefined | null): ToyPromise<T> {
      // æå‰å¤„ç† ToyPromise.ts:152 Uncaught (in toy-promise)ğŸ“Œ TypeError: onFinally is not a function è¿™ç§å¯èƒ½çš„æƒ…å†µ
      onFinally = typeof onFinally === "function" ? onFinally : () => {};

      return this.then(
        (value) => ToyPromise.resolve(onFinally!()).then(() => value),
        (reason) =>
          ToyPromise.resolve(onFinally!()).then(() => {
            throw reason;
          })
      );
    }

    /**
     * åˆ¤æ–­ä¸€ä¸ªå¯¹è±¡æ˜¯å¦ä¸º `thenable` å¯¹è±¡
     *
     * @param obj éœ€è¦è¿›è¡Œåˆ¤æ–­çš„å¯¹è±¡
     * @return å¯¹è±¡æ˜¯å¦ä¸º thenable å¯¹è±¡
     */
    static #isThenable(obj: any): boolean {
      if ((obj && typeof obj === "object") || typeof obj === "function") {
        return typeof obj["then"] === "function";
      }
      return false;
    }

    /**
     * åˆ¤æ–­ä¸€ä¸ªå¯¹è±¡æ˜¯å¦ä¸ºå¯è¿­ä»£å¯¹è±¡
     *
     * @param obj éœ€è¦è¿›è¡Œåˆ¤æ–­çš„å¯¹è±¡
     * @return å¯¹è±¡æ˜¯å¦ä¸ºå¯è¿­ä»£å¯¹è±¡
     */
    static #isIterable(obj: any): boolean {
      // é¿å… "" ç©ºå­—ç¬¦(é‚£ä¹ˆæ˜¯ iterable) è¢«åˆ¤æ–­ä¸º false æ¡ä»¶
      if (typeof obj === "string") {
        return true;
      }
      // å¦‚æœæ˜¯ null ç›´æ¥è¿”å› false
      if (typeof obj === "object" && !obj) {
        return false;
      }
      // åˆ¤æ–­æ˜¯å¦ä¸ºå¯è¿­ä»£å¯¹è±¡
      if (typeof obj === "function" || typeof obj === "object") {
        /*
          å…¼å®¹å¦‚ä¸‹è¿™ç§ç¤ºä¾‹æƒ…å†µ
          function foo() {}
          foo[Symbol.iterator] = () => { yield 233 }
        */
        return typeof obj[Symbol.iterator] === "function";
      } else {
        return false;
      }
    }

    /**
     * æ ¹æ®æ˜¯å¦åœ¨çŠ¶æ€æ˜¯å¦å·²å…‘ç°å‰æ‰“æ–­æ“ä½œè¿”å›å¤„ç†çš„ç»“æœ
     * å¦‚æœå½“å‰çŠ¶æ€ä¸ºæœªå…‘ç°(å³ä¸º: pending), é‚£ä¹ˆå°†å…¶æ“ä½œæå‰æ”¾å¼ƒ
     * å¦åˆ™å¦‚æœçŠ¶æ€å·²ç»å¤„äºç¡®å®šçŠ¶æ€: `fulfilled/rejected`, é‚£ä¹ˆä¸åšä»»ä½•ä¿®æ”¹
     *
     * @returns å¦‚æœåœ¨çŠ¶æ€æœªå…‘ç°å‰ç»“æŸæ“ä½œè¿”å› {@code true}, å¦åˆ™è¿”å› {@code false}
     */
    public abort(): boolean {
      if (this.#state === ToyPromiseStatus.PENDING) {
        this.#state = ToyPromiseStatus.ABORTED;
        this.#reason = "aborted";
        return true;
      } else {
        return false;
      }
    }

    /**
     * @param values å¯è¿­ä»£å¯¹è±¡
     * @returns å¦‚æœå¯è¿­ä»£å¯¹è±¡å†…çš„æ‰€æœ‰å…ƒç´ çš„å…‘ç°çŠ¶æ€ä¸ºå·²è§£å†³, é‚£ä¹ˆè¿”å›åŒ…å«å¯è¿­ä»£å¯¹è±¡éå†çš„æ‰€æœ‰å…ƒæ‰€ç»„æˆçš„å·²è§£å†³ `ToyPromise` å¯¹è±¡, å¦åˆ™è¿”å›åŒ…å«å·²æ‹’ç»çš„ `ToyPromise` å¯¹è±¡
     */
    public static all<T>(
      values: Iterable<T | PromiseLike<T>>
    ): ToyPromise<ToyPromiseAwaited<T>[]>;
    /**
     * @param values æ•°ç»„
     * @returns å¦‚æœæ•°ç»„å†…çš„æ‰€æœ‰å…ƒç´ çš„å…‘ç°çŠ¶æ€ä¸ºå·²è§£å†³, é‚£ä¹ˆè¿”å›åŒ…å«å¯è¿­ä»£å¯¹è±¡éå†çš„æ‰€æœ‰å…ƒæ‰€ç»„æˆçš„å·²è§£å†³ `ToyPromise` å¯¹è±¡, å¦åˆ™è¿”å›åŒ…å«å·²æ‹’ç»çš„ `ToyPromise` å¯¹è±¡
     */
    public static all<T extends readonly unknown[] | []>(
      values: T
    ): ToyPromise<{ -readonly [P in keyof T]: ToyPromiseAwaited<T[P]> }>;
    public static all<T>(values: any) {
      return new ToyPromise<any>((resolve, reject) => {
        // å¦‚æœæ¥æ”¶å€¼ä¸å¯è¿­ä»£, ç›´æ¥è¿”å›ä¸€ä¸ªåŒ…å«é”™è¯¯æç¤ºçš„ ToyPromise
        if (!this.#isIterable(values)) {
          throw new TypeError(
            `${typeof values} ${values} is not iterable (cannot read property Symbol(Symbol.iterator))`
          );
        } else {
          // å·²è§£å†³ç»Ÿè®¡
          let resolvedCount: number = 0;
          // å­˜æ”¾å·²è§£å†³å€¼çš„æ•°ç»„
          const resolvedList: Array<any> = [];
          const processStatus = (idx: number, data: any, countLen: number) => {
            resolvedList[idx] = data;
            if (++resolvedCount === countLen) {
              resolve(resolvedList as any);
            }
          };
          // å¦‚æœæ˜¯æ­£å¸¸ Array, ç›´æ¥éå†
          if (Array.isArray(values)) {
            const len0: number = values.length;
            loop: for (let i: number = 0; i < len0; ++i) {
              const current: any = values[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then((value) => {
                  processStatus(i, value, len0);
                }, reject);
              } else {
                processStatus(i, current, len0);
              }
            }
          } else {
            const tmpList: Array<any> = [];
            for (const val of values) {
              tmpList.push(val);
            }
            const len1: number = tmpList.length;
            for (let i: number = 0; i < len1; ++i) {
              const current = tmpList[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then((value) => {
                  processStatus(i, value, len1);
                }, reject);
              } else {
                processStatus(i, current, len1);
              }
            }
          }
        }
      });
    }

    /**
     * ç­‰å¾…æ‰€æœ‰å¯è¿­ä»£å¯¹è±¡å†…æ‰€æœ‰å…ƒç´ çŠ¶æ€å·²å…‘ç°(fulfilled æˆ–è€… rejected), è¿”å›å¤„ç†ç»“æœ
     *
     * @param values å¯è¿­ä»£å¯¹è±¡
     * @returns å¯è·Œæ‰“å…‘ç°å†…æ‰€æœ‰å…ƒç´ å…‘ç°çŠ¶æ€æ‰€ç»„æˆçš„æ•°ç»„(ä¼šç»´æŒå¯è¿­ä»£å…‘ç°å…ƒç´ éå†é¡ºåº)
     */
    public static allSettled<T>(
      values: Iterable<T | Thenable<T>>
    ): ToyPromise<ToyPromiseAllSettledResult<ToyPromiseAwaited<T>>[]>;
    /**
     * ç­‰å¾…æ‰€æœ‰å¯è¿­ä»£å¯¹è±¡çŠ¶æ€å·²å…‘ç°(fulfilled æˆ–è€… rejected), è¿”å›å¤„ç†ç»“æœ
     *
     * @param values ä¸€ä¸ªæ•°ç»„å¯¹è±¡(å…ƒç´ å¯ä»¥åŒ…å« Thenable å¯¹è±¡)
     * @returns æ‰€æœ‰å…ƒç´ å…‘ç°çŠ¶æ€æ‰€ç»„æˆçš„æ•°ç»„(ä¼šç»´æŒåŸæœ‰æ•°ç»„çš„å…ƒç´ ä½ç½®)
     */
    public static allSettled<T extends readonly unknown[] | []>(
      values: T
    ): ToyPromise<{
      -readonly [P in keyof T]: ToyPromiseAllSettledResult<
        ToyPromiseAwaited<T[P]>
      >;
    }>;
    public static allSettled<T>(values: any) {
      return new ToyPromise<any>((resolve) => {
        if (!this.#isIterable(values)) {
          if (!this.#isIterable(values)) {
            throw new TypeError(
              `${typeof values} ${values} is not iterable (cannot read property Symbol(Symbol.iterator))`
            );
          }
        } else {
          let doneCount: number = 0;
          const doneList: Array<any> = [];
          const processStatus = (
            idx: number,
            data: any,
            tType:
              | ToyPromiseStatus.FULFILLED
              | ToyPromiseStatus.REJECTED = ToyPromiseStatus.FULFILLED,
            length: number
          ): void => {
            doneList[idx] = {
              status:
                tType === ToyPromiseStatus.FULFILLED
                  ? tType
                  : ToyPromiseStatus.REJECTED,
              [tType === ToyPromiseStatus.FULFILLED ? "value" : "reason"]: data,
            };
            if (++doneCount === length) {
              resolve(doneList as any);
            }
          };

          if (Array.isArray(values)) {
            const arrLen0: number = values.length;
            for (let i: number = 0; i < arrLen0; ++i) {
              const current: any = values[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then(
                  (value) => {
                    processStatus(
                      i,
                      value,
                      ToyPromiseStatus.FULFILLED,
                      arrLen0
                    );
                  },
                  (reason) => {
                    processStatus(
                      i,
                      reason,
                      ToyPromiseStatus.REJECTED,
                      arrLen0
                    );
                  }
                );
              } else {
                processStatus(i, current, ToyPromiseStatus.FULFILLED, arrLen0);
              }
            }
          } else {
            const tmpList: Array<any> = [];
            for (const val of values) {
              tmpList.push(val);
            }
            const arrLen1: number = tmpList.length;
            for (let i: number = 0; i < arrLen1; ++i) {
              const current = tmpList[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then(
                  (value) => {
                    processStatus(
                      i,
                      value,
                      ToyPromiseStatus.FULFILLED,
                      arrLen1
                    );
                  },
                  (reason) => {
                    processStatus(
                      i,
                      reason,
                      ToyPromiseStatus.REJECTED,
                      arrLen1
                    );
                  }
                );
              } else {
                processStatus(i, current, ToyPromiseStatus.FULFILLED, arrLen1);
              }
            }
          }
        }
      });
    }

    /**
     * å¤„ç†å¯è¿­ä»£å¯¹è±¡çš„çŠ¶æ€å…‘ç°, åªè¦æœ‰ä¸€ä¸ªå…ƒç´ çš„çŠ¶æ€æœªå·²è§£å†³, é‚£ä¹ˆå°±ç«‹å³è¿”å›æ”¹å…ƒç´ çš„å·²è§£å†³çš„ `ToyPromise` å¯¹è±¡,
     * å¦‚æœæ‰€æœ‰å…ƒç´ çš„å¯¹è±¡çŠ¶æ€éƒ½ä¸º `rejected`, é‚£ä¹ˆè¿”å›ä¸€ä¸ªå·²æ‹’ç»çš„ `ToyPromise` å¯¹è±¡
     *
     * @param values å¯è¿­ä»£å¯¹è±¡
     * @returns é¦–ä¸ªçŠ¶æ€å…‘ç°ä¸º `fulfilled` çš„ `ToyPromise` å¯¹è±¡, å…¨éƒ¨ä¸ºå¤±è´¥æ—¶è¿”å›æ ‡è¯†å¤±è´¥çš„æ‹’ç» `ToyPromise` å¯¹è±¡
     */
    public static any<T>(
      values: Iterable<T | PromiseLike<T>>
    ): ToyPromise<ToyPromiseAwaited<T>>;
    /**
     * å¤„ç†æ•°ç»„å†…å¯¹è±¡çš„çŠ¶æ€å…‘ç°, åªè¦æœ‰ä¸€ä¸ªå…ƒç´ çš„çŠ¶æ€æœªå·²è§£å†³, é‚£ä¹ˆå°±ç«‹å³è¿”å›æ”¹å…ƒç´ çš„å·²è§£å†³çš„ `ToyPromise` å¯¹è±¡,
     * å¦‚æœæ‰€æœ‰å…ƒç´ çš„å¯¹è±¡çŠ¶æ€éƒ½ä¸º `rejected`, é‚£ä¹ˆè¿”å›ä¸€ä¸ªå·²æ‹’ç»çš„ `ToyPromise` å¯¹è±¡
     *
     * @param values æ•°ç»„
     * @returns é¦–ä¸ªçŠ¶æ€å…‘ç°ä¸º `fulfilled` çš„ `ToyPromise` å¯¹è±¡, å…¨éƒ¨ä¸ºå¤±è´¥æ—¶è¿”å›æ ‡è¯†å¤±è´¥çš„æ‹’ç» `ToyPromise` å¯¹è±¡
     */
    public static any<T extends readonly unknown[] | []>(
      values: T
    ): ToyPromise<ToyPromiseAwaited<T[number]>>;
    public static any<T>(values: any) {
      return new ToyPromise((resolve, reject) => {
        if (!this.#isIterable(values)) {
          throw new TypeError(
            `${typeof values} ${values} is not iterable (cannot read property Symbol(Symbol.iterator))`
          );
        } else {
          let rejectedCount: number = 0;
          if (Array.isArray(values)) {
            const len0: number = values.length;
            for (let i: number = 0; i < len0; ++i) {
              const current: any = values[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then(resolve as any, () => {
                  if (++rejectedCount === len0) {
                    reject(new AggregateError("All promises were rejected"));
                  }
                });
              } else {
                resolve(current as any);
              }
            }
          } else {
            const tmpList: Array<any> = [];
            for (const val of values) {
              tmpList.push(val);
            }
            const len1: number = tmpList.length;
            for (let i: number = 0; i < len1; ++i) {
              const current: any = tmpList[i];
              if (this.#isThenable(current)) {
                (<Thenable<T>>current).then(resolve as any, () => {
                  if (++rejectedCount === len1) {
                    reject(new AggregateError("All promises were rejected"));
                  }
                });
              } else {
                resolve(current as any);
              }
            }
          }
        }
      });
    }

    /**
     * å¤„ç†å¯è¿­ä»£å¯¹è±¡å†…ç¬¬ä¸€ä¸ªå…ƒç´ çŠ¶æ€å…‘ç°çš„ç»“æœ, æ ¹æ®è½åœ°çŠ¶æ€ç«‹å³è¿”å›å…¶ç»“æœ
     *
     * @param values å¯è¿­ä»£å¯¹è±¡
     * @returns é¦–ä¸ªçŠ¶æ€å·²å…‘ç° çš„ `ToyPromise` å¯¹è±¡
     */
    public static race<T>(
      values: Iterable<T | Thenable<T>>
    ): ToyPromise<ToyPromiseAwaited<T>>;
    /**
     * å¤„ç†å¯è¿­ä»£å¯¹è±¡å†…ç¬¬ä¸€ä¸ªå…ƒç´ çŠ¶æ€å…‘ç°çš„ç»“æœ, æ ¹æ®è½åœ°çŠ¶æ€ç«‹å³è¿”å›å…¶ç»“æœ
     *
     * @param values æ•°ç»„å¯¹è±¡
     * @returns é¦–ä¸ªçŠ¶æ€å·²å…‘ç° çš„ `ToyPromise` å¯¹è±¡
     */
    public static race<T extends readonly unknown[] | []>(
      values: T
    ): ToyPromise<ToyPromiseAwaited<T[number]>>;
    public static race<T>(values: any) {
      return new ToyPromise((resolve, reject) => {
        for (const val of values) {
          if (this.#isThenable(val)) {
            (<Thenable<T>>val).then(resolve as any, reject);
          } else {
            resolve(val as any);
          }
        }
      });
    }

    /**
     * @returns è¿”å›ä¸€ä¸ªçŠ¶æ€ä¸ºå·²è§£å†³çš„ ToyPromise<void> å¯¹è±¡
     */
    public static resolve(): ToyPromise<void>;
    /**
     * å¦‚æœä¼ å…¥å¯¹è±¡ä¸ºä¸€ä¸ª æœŸçº¦å¯¹è±¡, é‚£ä¹ˆè¿”å›çš„å¯¹è±¡ä¸ºå¹‚ç­‰, å³: a: Thenable; c = static.resolve(a), a === c
     *
     * @param value æœŸå¾…å€¼
     * @returns è¿”å›ä¸€ä¸ªçŠ¶æ€ä¸ºå·²è§£å†³çš„ ToyPromise<T> çš„å¯¹è±¡, å³ä½¿ä¼ å…¥çš„å¯¹è±¡ä¸ºä¸€ä¸ªæœªçŠ¶æ€æ‹’ç»çš„ Thenable å¯¹è±¡
     */
    public static resolve<T>(value: T): ToyPromise<ToyPromiseAwaited<T>>;
    /**
     * å¦‚æœä¼ å…¥å¯¹è±¡ä¸ºä¸€ä¸ª æœŸçº¦å¯¹è±¡, é‚£ä¹ˆè¿”å›çš„å¯¹è±¡ä¸ºå¹‚ç­‰, å³: a: Thenable; c = static.resolve(a), a === c
     *
     * @param value æœŸå¾…å€¼
     * @returns è¿”å›ä¸€ä¸ªçŠ¶æ€ä¸ºå·²è§£å†³çš„ ToyPromise<T> çš„å¯¹è±¡, å³ä½¿ä¼ å…¥çš„å¯¹è±¡ä¸ºä¸€ä¸ªæœªçŠ¶æ€æ‹’ç»çš„ Thenable å¯¹è±¡
     */
    public static resolve<T>(
      value: T | Thenable<T>
    ): ToyPromise<ToyPromiseAwaited<T>>;
    public static resolve(value?: any) {
      // æ¥å£å¹‚ç­‰, å…¼å®¹åŸç”Ÿ Promise å’Œè‡ªå®šä¹‰ Promise
      /*
        const p1 = new ToyPromise(()=> {});
        const p2 = ToyPromise.resolve(p1);
        console.log(p1 === p2); // true
      */

      /*
       const p1 = new ToyPromise((_ignored, reject) => {
        reject(111);
      });
        const p2 = ToyPromise.resolve(p1);
        console.log(p1 === p2); // true
      */
      if (value instanceof ToyPromise || value instanceof Promise) {
        return value;
      }
      return new ToyPromise((resolve) => {
        resolve(value);
      });
    }
    /**
     * @param reason å†³ç»åŸå› /å€¼
     * @returns è¿”å›ä¸€ä¸ªçŠ¶æ€ä¸ºå·²æ‹’ç»çš„ ToyPromise<T> çš„å¯¹è±¡
     */

    public static reject<T = never>(reason?: any): ToyPromise<T> {
      return new ToyPromise<T>((_ignore, reject) => {
        reject(reason);
      });
    }

    public get [Symbol.toStringTag](): string {
      return "ToyPromise";
    }
  }
  ```

  ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da7bad43403d471494ba17acbc6e02e2~tplv-k3u1fbpfcp-watermark.image?)

---

PREV: [JavaScript äº‹ä»¶å¾ªç¯æœºåˆ¶ç®€æ˜“è¯´æ˜](./2022-07-31.md)
æˆ–è€… [è¿”å›ç›®å½•](../index.md)
